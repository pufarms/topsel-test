# ìŠ¤ë§ˆíŠ¸ ì£¼ì†Œ ê²€ì¦ ì‹œìŠ¤í…œ v2.0 - í†µí•© ë¬¸ì„œ

> ì´ ë¬¸ì„œëŠ” ë‹¤ë¥¸ Replit í”„ë¡œì íŠ¸ì—ì„œ ë™ì¼í•œ ì£¼ì†Œ ê²€ì¦ ì‹œìŠ¤í…œì„ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì™„ì „í•œ ê°€ì´ë“œì…ë‹ˆë‹¤.

---

## ëª©ì°¨

1. [ì‹œìŠ¤í…œ ê°œìš”](#ì‹œìŠ¤í…œ-ê°œìš”)
2. [í•„ìˆ˜ í™˜ê²½ ì„¤ì •](#í•„ìˆ˜-í™˜ê²½-ì„¤ì •)
3. [ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ](#ë°ì´í„°ë² ì´ìŠ¤-ìŠ¤í‚¤ë§ˆ)
4. [í•µì‹¬ íŒŒì¼ êµ¬ì¡°](#í•µì‹¬-íŒŒì¼-êµ¬ì¡°)
5. [íŒŒì¼ë³„ ì „ì²´ ì½”ë“œ](#íŒŒì¼ë³„-ì „ì²´-ì½”ë“œ)
6. [API ì—”ë“œí¬ì¸íŠ¸](#api-ì—”ë“œí¬ì¸íŠ¸)
7. [í†µí•© ë°©ë²•](#í†µí•©-ë°©ë²•)

---

## ì‹œìŠ¤í…œ ê°œìš”

### ì‘ë™ íë¦„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ì‚¬ìš©ì ì—‘ì…€ ì—…ë¡œë“œ                                    â”‚
â”‚                          â†“                                              â”‚
â”‚                   ì£¼ì†Œ ì»¬ëŸ¼ ì¶”ì¶œ                                         â”‚
â”‚                          â†“                                              â”‚
â”‚              POST /api/address/validate                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                             â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               address-validation.ts                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 1ë‹¨ê³„: ì…ë ¥ ì •ê·œí™”                                                 â”‚  â”‚
â”‚  â”‚    - ê³µë°±/íŠ¹ìˆ˜ë¬¸ì ì •ë¦¬                                            â”‚  â”‚
â”‚  â”‚    - ê´„í˜¸ ë‚´ êµ¬ì£¼ì†Œ ì œê±°                                           â”‚  â”‚
â”‚  â”‚    - ì§€ì—­ ì•½ì–´ í™•ì¥ (ì„œìš¸ â†’ ì„œìš¸íŠ¹ë³„ì‹œ)                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                               â†“                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 2ë‹¨ê³„: Juso.go.kr API ê²€ìƒ‰                                        â”‚  â”‚
â”‚  â”‚    - ê²°ê³¼ 0ê±´? â†’ ì¬ì‹œë„ ì „ëµ ì‹¤í–‰                                  â”‚  â”‚
â”‚  â”‚    - ì—¬ëŸ¬ ê²°ê³¼? â†’ ìŠ¤ì½”ì–´ë§ìœ¼ë¡œ ìµœì  í›„ë³´ ì„ íƒ                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                               â†“                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ 3ë‹¨ê³„: ìƒì„¸ì£¼ì†Œ ê²€ì¦ (4ë‹¨ê³„ íŒŒì´í”„ë¼ì¸)                            â”‚  â”‚
â”‚  â”‚    STEP 0: ì •ê·œì‹ íŒ¨í„´ ë§¤ì¹­ (DB ì €ì¥ëœ íŒ¨í„´)                       â”‚  â”‚
â”‚  â”‚    STEP 1: í•™ìŠµ íŒ¨í„´ ê²€ìƒ‰ (ìœ ì‚¬ë„ ê¸°ë°˜)                            â”‚  â”‚
â”‚  â”‚    STEP 2: ë£° ê¸°ë°˜ ê²€ì¦ (ë™+í˜¸ íŒ¨í„´ ë“±)                            â”‚  â”‚
â”‚  â”‚    STEP 3: AI í†µí•© (í™•ì‹ ë„ < 0.9ì¼ ë•Œë§Œ)                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                               â†“                                         â”‚
â”‚                    ìµœì¢… ê²€ì¦ ê²°ê³¼ ë°˜í™˜                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ê²€ì¦ ìƒíƒœ (3ë‹¨ê³„)

| ìƒíƒœ | ìƒ‰ìƒ | ì˜ë¯¸ |
|------|------|------|
| **VALID** | ğŸŸ¢ ë…¹ìƒ‰ | ì£¼ì†Œ í™•ì¸ ì™„ë£Œ, ìƒì„¸ì£¼ì†Œ ì •ìƒ |
| **WARNING** | ğŸŸ¡ ë…¸ë€ìƒ‰ | ì£¼ì†ŒëŠ” ì°¾ì•˜ìœ¼ë‚˜ ìƒì„¸ì£¼ì†Œ ë¶ˆì™„ì „/ì˜ì‹¬ |
| **INVALID** | ğŸ”´ ë¹¨ê°„ìƒ‰ | ê±´ë¬¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ, ë°°ì†¡ ë¶ˆê°€ |

### ì£¼ìš” ê¸°ëŠ¥

- **Juso.go.kr API**: ì •ë¶€ ê³µì¸ í•œêµ­ ì£¼ì†Œ API
- **ì…ë ¥ ì •ê·œí™”**: ê³µë°±, íŠ¹ìˆ˜ë¬¸ì, êµ¬ì£¼ì†Œ í‘œê¸° ì •ë¦¬
- **ì¬ì‹œë„ ì „ëµ**: ê²€ìƒ‰ ì‹¤íŒ¨ ì‹œ í† í° ì œê±°, ê±´ë¬¼ëª… ì œê±° ë“± ìë™ ì¬ì‹œë„
- **ìƒì„¸ì£¼ì†Œ íŒ¨í„´ ê²€ì¦**: ë™+í˜¸, í•˜ì´í”ˆ, ë‹¨ìˆœ í˜¸/ì¸µ íŒ¨í„´ ê²€ì‚¬
- **AI ì •ê·œí™”**: Claude Sonnet 4ë¥¼ ì‚¬ìš©í•œ ìƒì„¸ì£¼ì†Œ ìë™ ì •ê·œí™”
- **ìë™ í•™ìŠµ**: AI ê²°ê³¼ë¥¼ DBì— ì €ì¥í•˜ì—¬ ì¬ì‚¬ìš©

---

## í•„ìˆ˜ í™˜ê²½ ì„¤ì •

### í™˜ê²½ ë³€ìˆ˜

```bash
# í•„ìˆ˜
JUSO_API_KEY=í–‰ì •ì•ˆì „ë¶€_ì£¼ì†ŒAPI_í‚¤

# AI ê¸°ëŠ¥ (ì„ íƒ, ê¶Œì¥)
ANTHROPIC_API_KEY=í´ë¡œë“œ_API_í‚¤
ENABLE_AI_ADDRESS_NORMALIZATION=true
AI_CONFIDENCE_THRESHOLD=0.9
```

### í•„ìˆ˜ íŒ¨í‚¤ì§€

```bash
npm install @anthropic-ai/sdk string-similarity
npm install -D @types/string-similarity
```

### Juso API í‚¤ ë°œê¸‰

1. https://www.juso.go.kr ì ‘ì†
2. íšŒì›ê°€ì… í›„ API ì‹ ì²­
3. ë°œê¸‰ë°›ì€ í‚¤ë¥¼ `JUSO_API_KEY`ì— ì„¤ì •

---

## ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### Drizzle ORM ìŠ¤í‚¤ë§ˆ (shared/schema.tsì— ì¶”ê°€)

```typescript
import { pgTable, serial, text, varchar, decimal, integer, boolean, timestamp, index } from 'drizzle-orm/pg-core';

export const addressLearningData = pgTable('address_learning_data', {
  id: serial('id').primaryKey(),
  
  // ì›ë³¸ ì£¼ì†Œ ì •ë³´
  originalAddress: text('original_address'),
  originalDetailAddress: text('original_detail_address').notNull(),
  buildingType: varchar('building_type', { length: 20 }),
  
  // ìˆ˜ì •ëœ ì£¼ì†Œ
  correctedDetailAddress: text('corrected_detail_address').notNull(),
  
  // ìˆ˜ì • ìœ í˜• (memo_separation, missing_unit_separator, hyphen_to_unit ë“±)
  correctionType: varchar('correction_type', { length: 50 }),
  
  // ì‹ ë¢°ë„ ë° í†µê³„
  confidenceScore: decimal('confidence_score', { precision: 3, scale: 2 }).default('0.80').notNull(),
  occurrenceCount: integer('occurrence_count').default(1).notNull(),
  successCount: integer('success_count').default(0).notNull(),
  userConfirmed: boolean('user_confirmed').default(false).notNull(),
  
  // AI íŒ¨í„´ ë¶„ì„ ê²°ê³¼
  errorPattern: varchar('error_pattern', { length: 100 }),
  problemDescription: text('problem_description'),
  patternRegex: varchar('pattern_regex', { length: 500 }),
  solutionDescription: text('solution_description'),
  similarPatterns: text('similar_patterns'),
  extractedMemo: text('extracted_memo'),
  analyzedAt: timestamp('analyzed_at'),
  aiModel: varchar('ai_model', { length: 50 }),
  
  // íƒ€ì„ìŠ¤íƒ¬í”„
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
  lastUsedAt: timestamp('last_used_at'),
}, (table) => ({
  originalDetailIdx: index('idx_original_detail').on(table.originalDetailAddress),
  buildingTypeIdx: index('idx_building_type').on(table.buildingType),
  patternIdx: index('idx_pattern_regex').on(table.patternRegex),
}));

export type AddressLearningData = typeof addressLearningData.$inferSelect;
export type NewAddressLearningData = typeof addressLearningData.$inferInsert;
```

### ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰

```bash
npm run db:push
```

---

## í•µì‹¬ íŒŒì¼ êµ¬ì¡°

```
server/
â”œâ”€â”€ address-validation.ts    # ë©”ì¸ ê²€ì¦ ë¡œì§ + API ë¼ìš°í„°
â”œâ”€â”€ address-learning.ts      # í•™ìŠµ íŒ¨í„´ ì €ì¥/ê²€ìƒ‰
â”œâ”€â”€ ai-address-enhancer.ts   # AI ìƒì„¸ì£¼ì†Œ ì •ê·œí™”
â””â”€â”€ ai-pattern-analyzer.ts   # AI íŒ¨í„´ ë¶„ì„
```

---

## íŒŒì¼ë³„ ì „ì²´ ì½”ë“œ

### 1. server/ai-address-enhancer.ts

```typescript
import Anthropic from '@anthropic-ai/sdk';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// íƒ€ì… ì •ì˜
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface AIEnhancementResult {
  normalized: string;              // ì •ê·œí™”ëœ ìƒì„¸ì£¼ì†Œ
  confidence: number;              // í™•ì‹ ë„ (0.0 ~ 1.0)
  reasoning: string;               // AI íŒë‹¨ ê·¼ê±°
  hasError: boolean;               // ì˜¤ë¥˜ ì—¬ë¶€
  suggestedCorrection?: string;    // ì œì•ˆ ìˆ˜ì •ì‚¬í•­
}

type BuildingType = 'apartment' | 'villa' | 'officetel' | 'general';

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Anthropic í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getAnthropicClient(): Anthropic | null {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  
  if (!apiKey) {
    console.warn('âš ï¸ ANTHROPIC_API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
    return null;
  }
  
  return new Anthropic({
    apiKey: apiKey,
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AI í™œì„±í™” ì—¬ë¶€ í™•ì¸
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function isAIEnabled(): boolean {
  const enabled = process.env.ENABLE_AI_ADDRESS_NORMALIZATION === 'true';
  const hasKey = !!process.env.ANTHROPIC_API_KEY;
  return enabled && hasKey;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// í•µì‹¬ í•¨ìˆ˜ 1: ìƒì„¸ì£¼ì†Œ ì •ê·œí™”
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function normalizeDetailAddressWithAI(
  rawDetailAddress: string,
  buildingType: BuildingType,
  buildingName?: string
): Promise<AIEnhancementResult> {
  
  // AI ë¹„í™œì„±í™” ì‹œ ê¸°ë³¸ê°’ ë°˜í™˜
  if (!isAIEnabled()) {
    return {
      normalized: rawDetailAddress,
      confidence: 0.5,
      reasoning: 'AI ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤.',
      hasError: false
    };
  }

  const client = getAnthropicClient();
  if (!client) {
    return {
      normalized: rawDetailAddress,
      confidence: 0.5,
      reasoning: 'Anthropic API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
      hasError: true
    };
  }

  try {
    const prompt = buildAIPrompt(rawDetailAddress, buildingType, buildingName);
    
    const message = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 500,
      temperature: 0.3,
      messages: [{
        role: 'user',
        content: prompt
      }]
    });

    // ì‘ë‹µ íŒŒì‹±
    const responseText = message.content[0].type === 'text' 
      ? message.content[0].text 
      : '';
    
    const result = parseAIResponse(responseText);
    
    console.log('âœ… AI ì •ê·œí™” ì„±ê³µ:', {
      input: rawDetailAddress,
      output: result.normalized,
      confidence: result.confidence
    });
    
    return result;

  } catch (error: any) {
    console.error('âŒ AI ì •ê·œí™” ì‹¤íŒ¨:', error.message);
    return {
      normalized: rawDetailAddress,
      confidence: 0.3,
      reasoning: `AI í˜¸ì¶œ ì‹¤íŒ¨: ${error.message}`,
      hasError: true
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// í•µì‹¬ í•¨ìˆ˜ 2: AI í”„ë¡¬í”„íŠ¸ ìƒì„±
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildAIPrompt(
  rawDetailAddress: string,
  buildingType: BuildingType,
  buildingName?: string
): string {
  
  const buildingTypeKo = {
    apartment: 'ì•„íŒŒíŠ¸',
    villa: 'ë¹Œë¼',
    officetel: 'ì˜¤í”¼ìŠ¤í…”',
    general: 'ì¼ë°˜ ê±´ë¬¼'
  }[buildingType];

  return `ë‹¹ì‹ ì€ í•œêµ­ ì£¼ì†Œ ì •ê·œí™” ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

**ì…ë ¥ ì •ë³´:**
- ì›ë³¸ ìƒì„¸ì£¼ì†Œ: "${rawDetailAddress}"
- ê±´ë¬¼ ìœ í˜•: ${buildingTypeKo}
${buildingName ? `- ê±´ë¬¼ëª…: ${buildingName}` : ''}

**ì‘ì—… ìš”ì²­:**
1. ìƒì„¸ì£¼ì†Œë¥¼ í‘œì¤€ í˜•ì‹ìœ¼ë¡œ ì •ê·œí™”í•˜ì„¸ìš”.
2. ë‹¤ìŒ íŒ¨í„´ì„ ì ìš©í•˜ì„¸ìš”:
   - "101 1001" â†’ "101ë™ 1001í˜¸"
   - "A-302" â†’ "Aë™ 302í˜¸"
   - "ì§€í•˜ 1ì¸µ" â†’ "ì§€í•˜1ì¸µ"
   - "101ë™ 1001í˜¸ (ë¶€ì¬ì‹œ ë¬¸ì•)" â†’ "101ë™ 1001í˜¸" (ë©”ëª¨ ì œê±°)
   - "í…Œí—¤ë€ë…¸" â†’ "í…Œí—¤ë€ë¡œ" (ì˜¤íƒ€ êµì •)

3. ${buildingTypeKo === 'ì•„íŒŒíŠ¸' ? 'ì•„íŒŒíŠ¸ëŠ” ë°˜ë“œì‹œ "ë™+í˜¸" í˜•ì‹ì´ì–´ì•¼ í•©ë‹ˆë‹¤.' : ''}

**ì‘ë‹µ í˜•ì‹ (JSONë§Œ ì¶œë ¥):**
\`\`\`json
{
  "normalized": "ì •ê·œí™”ëœ ì£¼ì†Œ",
  "confidence": 0.95,
  "reasoning": "íŒë‹¨ ê·¼ê±°",
  "hasError": false,
  "suggestedCorrection": "ì¶”ê°€ ì œì•ˆì‚¬í•­ (ì„ íƒ)"
}
\`\`\`

**ì œì•½ì‚¬í•­:**
- JSON í˜•ì‹ë§Œ ì¶œë ¥í•˜ì„¸ìš”.
- ë¶ˆí•„ìš”í•œ ì„¤ëª…ì„ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.
- confidenceëŠ” 0.0~1.0 ì‚¬ì´ ê°’ì…ë‹ˆë‹¤.`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// í•µì‹¬ í•¨ìˆ˜ 3: AI ì‘ë‹µ íŒŒì‹±
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function parseAIResponse(responseText: string): AIEnhancementResult {
  try {
    // JSON ì½”ë“œ ë¸”ë¡ ì œê±°
    const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                      responseText.match(/\{[\s\S]*\}/);
    
    const jsonText = jsonMatch ? jsonMatch[1] || jsonMatch[0] : responseText;
    const parsed = JSON.parse(jsonText);
    
    return {
      normalized: parsed.normalized || '',
      confidence: parsed.confidence || 0.7,
      reasoning: parsed.reasoning || 'AI ì‘ë‹µ íŒŒì‹± ì™„ë£Œ',
      hasError: parsed.hasError || false,
      suggestedCorrection: parsed.suggestedCorrection
    };
    
  } catch (error) {
    console.error('JSON íŒŒì‹± ì‹¤íŒ¨:', responseText);
    return {
      normalized: '',
      confidence: 0.3,
      reasoning: 'AI ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨',
      hasError: true
    };
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// í•µì‹¬ í•¨ìˆ˜ 4: ì˜¤íƒ€ êµì •
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export async function correctAddressTypo(
  address: string
): Promise<{ corrected: string; confidence: number }> {
  
  if (!isAIEnabled()) {
    return { corrected: address, confidence: 0.5 };
  }

  const client = getAnthropicClient();
  if (!client) {
    return { corrected: address, confidence: 0.5 };
  }

  try {
    const prompt = `ë‹¤ìŒ ì£¼ì†Œì˜ ì˜¤íƒ€ë¥¼ êµì •í•˜ì„¸ìš”:
"${address}"

ì¼ë°˜ì ì¸ ì˜¤íƒ€ ì˜ˆì‹œ:
- "í…Œí—¤ë€ë…¸" â†’ "í…Œí—¤ë€ë¡œ"
- "ê°•ë‚¨ë°ë¡œ" â†’ "ê°•ë‚¨ëŒ€ë¡œ"

JSON í˜•ì‹ìœ¼ë¡œ ì‘ë‹µ:
\`\`\`json
{
  "corrected": "êµì •ëœ ì£¼ì†Œ",
  "confidence": 0.95
}
\`\`\``;

    const message = await client.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 300,
      temperature: 0.1,
      messages: [{ role: 'user', content: prompt }]
    });

    const responseText = message.content[0].type === 'text' 
      ? message.content[0].text 
      : '';
    
    const jsonMatch = responseText.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      const parsed = JSON.parse(jsonMatch[0]);
      return {
        corrected: parsed.corrected || address,
        confidence: parsed.confidence || 0.7
      };
    }

    return { corrected: address, confidence: 0.5 };

  } catch (error) {
    console.error('ì˜¤íƒ€ êµì • ì‹¤íŒ¨:', error);
    return { corrected: address, confidence: 0.3 };
  }
}
```

### 2. server/ai-pattern-analyzer.ts

```typescript
import Anthropic from '@anthropic-ai/sdk';

export interface PatternAnalysisResult {
  originalAddress: string;
  correctedAddress: string;
  errorPattern: string;
  problemDescription: string;
  patternRegex: string;
  solution: string;
  buildingType: string;
  confidence: number;
  similarPatterns: string[];
  extractedMemo?: string;
}

function getAnthropicClient(): Anthropic | null {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) return null;
  return new Anthropic({ apiKey });
}

export async function analyzeAddressPattern(
  errorAddress: string
): Promise<PatternAnalysisResult | null> {
  
  const client = getAnthropicClient();
  if (!client) {
    console.error('Anthropic API í‚¤ ì—†ìŒ');
    return null;
  }

  const prompt = `ë‹¹ì‹ ì€ í•œêµ­ ì£¼ì†Œ ì˜¤ë¥˜ íŒ¨í„´ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

**ì…ë ¥ëœ ì˜¤ë¥˜ ì£¼ì†Œ:**
"${errorAddress}"

**ì‘ì—…:**
1. ì´ ì£¼ì†Œê°€ ì™œ ì˜¤ë¥˜ì¸ì§€ ë¶„ì„í•˜ì„¸ìš”
2. ì˜¤ë¥˜ íŒ¨í„´ì„ ì‹ë³„í•˜ì„¸ìš”
3. ì •ìƒ ì£¼ì†Œë¡œ ë³€í™˜í•˜ì„¸ìš”
4. ìœ ì‚¬í•œ ì˜¤ë¥˜ íŒ¨í„´ì„ ì˜ˆì¸¡í•˜ì„¸ìš”
5. ì´ íŒ¨í„´ì„ ê°ì§€í•  ì •ê·œì‹ì„ ìƒì„±í•˜ì„¸ìš”

**ì‘ë‹µ í˜•ì‹ (JSONë§Œ ì¶œë ¥):**
\`\`\`json
{
  "originalAddress": "ì›ë³¸ ì£¼ì†Œ",
  "correctedAddress": "ì •ìƒ ì£¼ì†Œ",
  "errorPattern": "ì˜¤ë¥˜_íŒ¨í„´_ì½”ë“œ",
  "problemDescription": "ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ì§€ í•œê¸€ë¡œ ì„¤ëª…",
  "patternRegex": "ì´ íŒ¨í„´ì„ ê°ì§€í•  ì •ê·œì‹ (ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬)",
  "solution": "ì–´ë–»ê²Œ ìˆ˜ì •í–ˆëŠ”ì§€ ì„¤ëª…",
  "buildingType": "apartment|villa|officetel|general",
  "confidence": 0.95,
  "similarPatterns": [
    "ìœ ì‚¬í•œ ì˜¤ë¥˜ íŒ¨í„´ ì˜ˆì‹œ 3ê°œ"
  ],
  "extractedMemo": "ë©”ëª¨ê°€ ìˆì—ˆë‹¤ë©´ ì¶”ì¶œ (ì—†ìœ¼ë©´ null)"
}
\`\`\`

**ì˜¤ë¥˜ íŒ¨í„´ ì½”ë“œ ì˜ˆì‹œ:**
- SPACE_SEPARATED_UNIT_HO: ê³µë°±ìœ¼ë¡œë§Œ êµ¬ë¶„ (ì˜ˆ: "101 1001")
- HYPHEN_SEPARATED_UNIT_HO: í•˜ì´í”ˆ êµ¬ë¶„ (ì˜ˆ: "A-302")
- MEMO_MIXED: ë°°ì†¡ ë©”ëª¨ í˜¼ì… (ì˜ˆ: "101ë™ 1001í˜¸ (ë¶€ì¬ì‹œ ë¬¸ì•)")
- TYPO_IN_ROAD: ë„ë¡œëª… ì˜¤íƒ€ (ì˜ˆ: "í…Œí—¤ë€ë…¸" â†’ "í…Œí—¤ë€ë¡œ")
- MISSING_UNIT: ë™ ëˆ„ë½
- MISSING_HO: í˜¸ ëˆ„ë½
- FLOOR_SPACE: ì¸µ í‘œê¸° ê³µë°± (ì˜ˆ: "ì§€í•˜ 1ì¸µ")
- INVALID_FORMAT: í˜•ì‹ ì˜¤ë¥˜

**ì •ê·œì‹ ì‘ì„± ê·œì¹™:**
- ë°±ìŠ¬ë˜ì‹œëŠ” ì´ì¤‘ ì´ìŠ¤ì¼€ì´í”„: \\\\d (JSONì—ì„œ \\dë¡œ íŒŒì‹±ë¨)
- ê·¸ë£¹ ìº¡ì²˜ ì‚¬ìš©: (\\\\d{1,3})\\\\s+(\\\\d{3,4})
- í…ŒìŠ¤íŠ¸ ê°€ëŠ¥í•œ ì •ê·œì‹ ìƒì„±

ì¤‘ìš”: JSONë§Œ ì¶œë ¥í•˜ê³  ë‹¤ë¥¸ ì„¤ëª…ì€ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.`;

  try {
    const message = await client.messages.create({
      model: 'claude-sonnet-4-5-20250514',
      max_tokens: 1000,
      temperature: 0.2,
      messages: [{ role: 'user', content: prompt }]
    });

    const responseText = message.content[0].type === 'text' 
      ? message.content[0].text 
      : '';

    const jsonMatch = responseText.match(/```json\s*([\s\S]*?)\s*```/) || 
                      responseText.match(/\{[\s\S]*\}/);
    
    if (!jsonMatch) {
      console.error('JSON íŒŒì‹± ì‹¤íŒ¨:', responseText);
      return null;
    }

    const jsonText = jsonMatch[1] || jsonMatch[0];
    const parsed = JSON.parse(jsonText);

    console.log('âœ… íŒ¨í„´ ë¶„ì„ ì™„ë£Œ:', {
      pattern: parsed.errorPattern,
      confidence: parsed.confidence
    });

    return parsed;

  } catch (error: any) {
    console.error('íŒ¨í„´ ë¶„ì„ ì‹¤íŒ¨:', error.message);
    return null;
  }
}

export function matchAndConvertByPattern(
  address: string,
  patternRegex: string,
  correctedTemplate: string
): string | null {
  try {
    const regex = new RegExp(patternRegex);
    const match = address.match(regex);
    
    if (!match) return null;
    
    const hasPlaceholders = /\$\d/.test(correctedTemplate);
    
    if (hasPlaceholders) {
      let result = correctedTemplate;
      let substituted = false;
      
      match.forEach((group, idx) => {
        if (idx > 0 && group) {
          const placeholder = `$${idx}`;
          if (result.includes(placeholder)) {
            result = result.replace(placeholder, group);
            substituted = true;
          }
        }
      });
      
      if (!substituted) {
        console.warn('íŒ¨í„´ í…œí”Œë¦¿ì— ìœ íš¨í•œ ì¹˜í™˜ì´ ì—†ìŒ:', correctedTemplate);
        return null;
      }
      
      return result;
    } else {
      return correctedTemplate;
    }
    
  } catch (error) {
    console.error('íŒ¨í„´ ë§¤ì¹­ ì‹¤íŒ¨:', error);
    return null;
  }
}
```

### 3. server/address-learning.ts

```typescript
import { db } from './db';
import { addressLearningData } from '@shared/schema';
import { eq, and, gte, desc, isNotNull, sql } from 'drizzle-orm';
import { PatternAnalysisResult } from './ai-pattern-analyzer';
import { compareTwoStrings } from 'string-similarity';

/**
 * ì‚¬ìš©ìê°€ ì£¼ì†Œë¥¼ ìˆ˜ì •í–ˆì„ ë•Œ í•™ìŠµ ë°ì´í„°ë¡œ ì €ì¥
 */
export async function saveAddressCorrection(
  originalDetailAddress: string,
  correctedDetailAddress: string,
  buildingType: string,
  correctionType: string
): Promise<void> {
  try {
    const existing = await db
      .select()
      .from(addressLearningData)
      .where(
        and(
          eq(addressLearningData.originalDetailAddress, originalDetailAddress),
          eq(addressLearningData.buildingType, buildingType)
        )
      )
      .limit(1);
    
    if (existing.length > 0) {
      const existingData = existing[0];
      
      const newConfidence = 
        existingData.correctedDetailAddress === correctedDetailAddress
          ? Math.min(Number(existingData.confidenceScore) + 0.05, 1.0)
          : Number(existingData.confidenceScore) * 0.8;
      
      await db
        .update(addressLearningData)
        .set({
          occurrenceCount: existingData.occurrenceCount + 1,
          confidenceScore: newConfidence.toFixed(2),
          updatedAt: new Date(),
          correctedDetailAddress: correctedDetailAddress
        })
        .where(eq(addressLearningData.id, existingData.id));
      
      console.log('[í•™ìŠµ] ê¸°ì¡´ íŒ¨í„´ ì—…ë°ì´íŠ¸:', {
        original: originalDetailAddress,
        corrected: correctedDetailAddress,
        occurrenceCount: existingData.occurrenceCount + 1,
        confidence: newConfidence.toFixed(2)
      });
      
    } else {
      await db.insert(addressLearningData).values({
        originalDetailAddress,
        correctedDetailAddress,
        buildingType,
        correctionType,
        confidenceScore: '0.70',
        occurrenceCount: 1,
        successCount: 0,
        userConfirmed: false
      });
      
      console.log('[í•™ìŠµ] ìƒˆ íŒ¨í„´ ì €ì¥:', {
        original: originalDetailAddress,
        corrected: correctedDetailAddress,
        type: buildingType
      });
    }
    
  } catch (error) {
    console.error('[í•™ìŠµ] ì €ì¥ ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * ë¬¸ìì—´ ìœ ì‚¬ë„ ê¸°ë°˜ìœ¼ë¡œ ë¹„ìŠ·í•œ íŒ¨í„´ ì°¾ê¸°
 */
async function findSimilarPattern(
  detailAddress: string,
  buildingType: string
): Promise<{
  found: boolean;
  corrected: string;
  confidence: number;
  occurrenceCount: number;
} | null> {
  
  try {
    const allPatterns = await db
      .select()
      .from(addressLearningData)
      .where(
        and(
          eq(addressLearningData.buildingType, buildingType),
          gte(addressLearningData.confidenceScore, '0.80')
        )
      )
      .orderBy(desc(addressLearningData.occurrenceCount))
      .limit(100);
    
    let bestMatch = null;
    let bestSimilarity = 0;
    
    for (const pattern of allPatterns) {
      const similarity = compareTwoStrings(
        detailAddress.toLowerCase(),
        pattern.originalDetailAddress.toLowerCase()
      );
      
      if (similarity > bestSimilarity && similarity >= 0.85) {
        bestSimilarity = similarity;
        bestMatch = pattern;
      }
    }
    
    if (bestMatch && bestSimilarity >= 0.85) {
      return {
        found: true,
        corrected: bestMatch.correctedDetailAddress,
        confidence: bestSimilarity,
        occurrenceCount: bestMatch.occurrenceCount
      };
    }
    
    return null;
    
  } catch (error) {
    console.error('[í•™ìŠµ] ìœ ì‚¬ íŒ¨í„´ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * í•™ìŠµëœ ë°ì´í„°ì—ì„œ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ” íŒ¨í„´ ì°¾ê¸°
 */
export async function findLearnedPattern(
  detailAddress: string,
  buildingType: string
): Promise<{
  found: boolean;
  corrected?: string;
  confidence?: number;
  occurrenceCount?: number;
} | null> {
  
  try {
    const exactMatch = await db
      .select()
      .from(addressLearningData)
      .where(
        and(
          eq(addressLearningData.originalDetailAddress, detailAddress),
          eq(addressLearningData.buildingType, buildingType),
          gte(addressLearningData.confidenceScore, '0.80'),
          gte(addressLearningData.occurrenceCount, 3)
        )
      )
      .orderBy(desc(addressLearningData.occurrenceCount))
      .limit(1);
    
    if (exactMatch.length > 0) {
      const match = exactMatch[0];
      
      await db
        .update(addressLearningData)
        .set({
          lastUsedAt: new Date(),
          successCount: match.successCount + 1
        })
        .where(eq(addressLearningData.id, match.id));
      
      console.log('[í•™ìŠµ] ì •í™• ë§¤ì¹­ ë°œê²¬:', {
        original: detailAddress,
        corrected: match.correctedDetailAddress,
        confidence: match.confidenceScore,
        occurrenceCount: match.occurrenceCount
      });
      
      return {
        found: true,
        corrected: match.correctedDetailAddress,
        confidence: Number(match.confidenceScore),
        occurrenceCount: match.occurrenceCount
      };
    }
    
    const similarPattern = await findSimilarPattern(detailAddress, buildingType);
    
    if (similarPattern) {
      console.log('[í•™ìŠµ] ìœ ì‚¬ íŒ¨í„´ ë°œê²¬:', similarPattern);
      return similarPattern;
    }
    
    console.log('[í•™ìŠµ] íŒ¨í„´ ì—†ìŒ:', detailAddress);
    return null;
    
  } catch (error) {
    console.error('[í•™ìŠµ] ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return null;
  }
}

/**
 * ì›ë³¸ê³¼ ìˆ˜ì •ëœ ì£¼ì†Œë¥¼ ë¹„êµí•˜ì—¬ ìˆ˜ì • ìœ í˜• ìë™ ì¶”ë¡ 
 */
export function inferCorrectionType(original: string, corrected: string): string {
  if (original.includes('(') || original.includes(')') || 
      original.includes('ë¶€ì¬ì‹œ') || original.includes('ê²½ë¹„ì‹¤') || 
      original.includes('ë¬¸ì•') || original.includes('íƒë°°í•¨')) {
    return 'memo_separation';
  }
  
  if (/^\d+\s+\d+$/.test(original.trim())) {
    return 'missing_unit_separator';
  }
  
  if (/^[A-Zê°€-í£]-?\d+$/.test(original.trim())) {
    return 'hyphen_to_unit';
  }
  
  if (original.includes('ì¸µ') || original.includes('F') || original.includes('B')) {
    return 'floor_normalization';
  }
  
  return 'unknown';
}

/**
 * ì‚¬ìš©ìê°€ ì§ì ‘ ìˆ˜ì •í•œ ê²½ìš° ì‹ ë¢°ë„ë¥¼ ë†’ê²Œ ì„¤ì •
 */
export async function markUserConfirmed(
  originalDetailAddress: string,
  buildingType: string
): Promise<void> {
  try {
    await db
      .update(addressLearningData)
      .set({
        userConfirmed: true,
        confidenceScore: '0.95',
        updatedAt: new Date()
      })
      .where(
        and(
          eq(addressLearningData.originalDetailAddress, originalDetailAddress),
          eq(addressLearningData.buildingType, buildingType)
        )
      );
    
    console.log('[í•™ìŠµ] ì‚¬ìš©ì í™•ì¸ ì—…ë°ì´íŠ¸:', originalDetailAddress);
    
  } catch (error) {
    console.error('[í•™ìŠµ] ì‚¬ìš©ì í™•ì¸ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
  }
}

/**
 * AI íŒ¨í„´ ë¶„ì„ ê²°ê³¼ ì €ì¥
 */
export async function savePatternAnalysis(
  analysis: PatternAnalysisResult
): Promise<void> {
  try {
    const existing = await db
      .select()
      .from(addressLearningData)
      .where(eq(addressLearningData.originalDetailAddress, analysis.originalAddress))
      .limit(1);
    
    if (existing.length > 0) {
      await db
        .update(addressLearningData)
        .set({
          correctedDetailAddress: analysis.correctedAddress,
          errorPattern: analysis.errorPattern,
          problemDescription: analysis.problemDescription,
          patternRegex: analysis.patternRegex,
          solutionDescription: analysis.solution,
          similarPatterns: JSON.stringify(analysis.similarPatterns),
          extractedMemo: analysis.extractedMemo || null,
          analyzedAt: new Date(),
          aiModel: 'claude-sonnet-4-5-20250514',
          confidenceScore: String(analysis.confidence),
          occurrenceCount: existing[0].occurrenceCount + 1,
          updatedAt: new Date()
        })
        .where(eq(addressLearningData.id, existing[0].id));
      
      console.log('âœ… íŒ¨í„´ ë¶„ì„ ì—…ë°ì´íŠ¸:', analysis.errorPattern);
    } else {
      await db.insert(addressLearningData).values({
        originalAddress: null,
        originalDetailAddress: analysis.originalAddress,
        correctedDetailAddress: analysis.correctedAddress,
        buildingType: analysis.buildingType,
        correctionType: analysis.errorPattern,
        confidenceScore: String(analysis.confidence),
        occurrenceCount: 1,
        successCount: 0,
        userConfirmed: true,
        errorPattern: analysis.errorPattern,
        problemDescription: analysis.problemDescription,
        patternRegex: analysis.patternRegex,
        solutionDescription: analysis.solution,
        similarPatterns: JSON.stringify(analysis.similarPatterns),
        extractedMemo: analysis.extractedMemo || null,
        analyzedAt: new Date(),
        aiModel: 'claude-sonnet-4-5-20250514'
      });
      
      console.log('âœ… íŒ¨í„´ ë¶„ì„ ì €ì¥ ì™„ë£Œ:', analysis.errorPattern);
    }
    
  } catch (error) {
    console.error('íŒ¨í„´ ì €ì¥ ì‹¤íŒ¨:', error);
    throw error;
  }
}

/**
 * ì •ê·œì‹ íŒ¨í„´ ê¸°ë°˜ ì£¼ì†Œ ê²€ìƒ‰
 */
export async function findByPattern(
  address: string,
  buildingType?: string
): Promise<{
  id: number;
  errorPattern: string | null;
  patternRegex: string | null;
  correctedDetailAddress: string;
  confidenceScore: string;
  buildingType: string | null;
} | null> {
  try {
    const minConfidence = 0.7;
    
    let query = db
      .select()
      .from(addressLearningData)
      .where(
        and(
          isNotNull(addressLearningData.patternRegex),
          gte(addressLearningData.confidenceScore, String(minConfidence))
        )
      )
      .orderBy(desc(addressLearningData.confidenceScore), desc(addressLearningData.occurrenceCount));
    
    const patterns = await query;
    
    for (const pattern of patterns) {
      try {
        if (!pattern.patternRegex) continue;
        
        if (buildingType && pattern.buildingType && pattern.buildingType !== buildingType) {
          continue;
        }
        
        const regex = new RegExp(pattern.patternRegex);
        if (regex.test(address)) {
          console.log(`ğŸ“š íŒ¨í„´ ë§¤ì¹­: ${pattern.errorPattern} (ì‹ ë¢°ë„: ${pattern.confidenceScore})`);
          return {
            id: pattern.id,
            errorPattern: pattern.errorPattern,
            patternRegex: pattern.patternRegex,
            correctedDetailAddress: pattern.correctedDetailAddress,
            confidenceScore: pattern.confidenceScore,
            buildingType: pattern.buildingType
          };
        }
      } catch (error) {
        continue;
      }
    }
    
    return null;
    
  } catch (error) {
    console.error('íŒ¨í„´ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
    return null;
  }
}
```

### 4. server/address-validation.ts (í•µì‹¬ ë¡œì§)

> **ì°¸ê³ **: ì´ íŒŒì¼ì€ ì•½ 1,400ì¤„ì…ë‹ˆë‹¤. ì „ì²´ ì½”ë“œëŠ” TopselPro í”„ë¡œì íŠ¸ì˜ `server/address-validation.ts`ë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.

#### ì£¼ìš” êµ¬ì„± ìš”ì†Œ

```typescript
import { Router, Request, Response } from "express";
import { 
  normalizeDetailAddressWithAI, 
  isAIEnabled,
  type AIEnhancementResult 
} from './ai-address-enhancer';
import {
  saveAddressCorrection,
  findLearnedPattern,
  inferCorrectionType,
  findByPattern
} from './address-learning';
import { matchAndConvertByPattern } from './ai-pattern-analyzer';

const router = Router();

const JUSO_API_KEY = process.env.JUSO_API_KEY;
const JUSO_API_ENDPOINT = "https://www.juso.go.kr/addrlink/addrLinkApi.do";

// ê²€ì¦ ìƒíƒœ íƒ€ì…
export type AddressStatus = "valid" | "warning" | "invalid";

// ê²€ì¦ ê²°ê³¼ ì¸í„°í˜ì´ìŠ¤
export interface AddressValidationResult {
  rowIndex: number;
  originalAddress: string;
  status: AddressStatus;
  standardAddress?: string;
  detailAddress?: string;
  normalizedDetailAddress?: string;
  fullAddress?: string;
  zipCode?: string;
  buildingName?: string;
  warningMessage?: string;
  errorMessage?: string;
  reasonCode?: string;
  isIslandRemote?: boolean;
  isLengthExceeded?: boolean;
  originalPhone?: string;
  formattedPhone?: string;
  phoneModified?: boolean;
}

// ê¸ˆì§€ì–´ ëª©ë¡
const FORBIDDEN_WORDS = [
  "ë¯¸ì •", "ëª°ë¼", "unknown", "ëª¨ë¦„", "ë‚˜ì¤‘ì—",
  "ì¶”í›„", "í™•ì¸ìš”", "í…ŒìŠ¤íŠ¸", "test",
  "ã…‡ã…‡", "ã…ã…", "ã„´ã„´", "asdf", "qwer", "zxcv"
];

// ë„ì„œ/ì‚°ê°„ ì§€ì—­
const ISLAND_REMOTE_REGIONS = ["ì œì£¼", "ìš¸ë¦‰", "ì‹ ì•ˆ", "ì™„ë„", "ì§„ë„", "í‘ì‚°ë„", "ë°±ë ¹ë„", "ì—°í‰ë„"];

// ì•„íŒŒíŠ¸ í‚¤ì›Œë“œ (ë™+í˜¸ í•„ìˆ˜)
const STRICT_APT_KEYWORDS = ["ì•„íŒŒíŠ¸", "APT", "ê³µë™ì£¼íƒ", "ì—°ë¦½", "ë‹¤ì„¸ëŒ€"];

// ë¹Œë¼/ì˜¤í”¼ìŠ¤í…” í‚¤ì›Œë“œ (í˜¸ë§Œ ìˆì–´ë„ ë¨)
const RELAXED_APT_KEYWORDS = ["ë¹Œë¼", "ì£¼ìƒë³µí•©", "ì˜¤í”¼ìŠ¤í…”", "íƒ€ìš´í•˜ìš°ìŠ¤", "íƒ€ì›Œ", "ë§¨ì…˜", "íŒ°ë¦¬ìŠ¤", "ë¹Œë”©", "ë ˆì§€ë˜ìŠ¤", "í•˜ì´ì¸ "];

// ì§€ì—­ ì•½ì–´ ë§¤í•‘
const REGION_ABBREVIATIONS: Record<string, string> = {
  "ì„œìš¸": "ì„œìš¸íŠ¹ë³„ì‹œ",
  "ë¶€ì‚°": "ë¶€ì‚°ê´‘ì—­ì‹œ",
  "ëŒ€êµ¬": "ëŒ€êµ¬ê´‘ì—­ì‹œ",
  "ì¸ì²œ": "ì¸ì²œê´‘ì—­ì‹œ",
  "ê´‘ì£¼": "ê´‘ì£¼ê´‘ì—­ì‹œ",
  "ëŒ€ì „": "ëŒ€ì „ê´‘ì—­ì‹œ",
  "ìš¸ì‚°": "ìš¸ì‚°ê´‘ì—­ì‹œ",
  "ì„¸ì¢…": "ì„¸ì¢…íŠ¹ë³„ìì¹˜ì‹œ",
  "ê²½ê¸°": "ê²½ê¸°ë„",
  "ê°•ì›": "ê°•ì›íŠ¹ë³„ìì¹˜ë„",
  "ì¶©ë¶": "ì¶©ì²­ë¶ë„",
  "ì¶©ë‚¨": "ì¶©ì²­ë‚¨ë„",
  "ì „ë¶": "ì „ë¶íŠ¹ë³„ìì¹˜ë„",
  "ì „ë‚¨": "ì „ë¼ë‚¨ë„",
  "ê²½ë¶": "ê²½ìƒë¶ë„",
  "ê²½ë‚¨": "ê²½ìƒë‚¨ë„",
  "ì œì£¼": "ì œì£¼íŠ¹ë³„ìì¹˜ë„",
};

// ... ë‚˜ë¨¸ì§€ í•¨ìˆ˜ë“¤ì€ TopselPro í”„ë¡œì íŠ¸ ì°¸ì¡°
```

#### í•µì‹¬ í•¨ìˆ˜ ëª©ë¡

| í•¨ìˆ˜ëª… | ì„¤ëª… |
|--------|------|
| `normalizeAddress()` | ì…ë ¥ ì£¼ì†Œ ì •ê·œí™” |
| `callJusoAPI()` | Juso.go.kr API í˜¸ì¶œ |
| `validateDetailAddress()` | ìƒì„¸ì£¼ì†Œ 4ë‹¨ê³„ ê²€ì¦ |
| `validateDetailAddressWithRules()` | ë£° ê¸°ë°˜ ê²€ì¦ |
| `extractDetailAddress()` | ìƒì„¸ì£¼ì†Œ ì¶”ì¶œ |
| `formatPhoneNumber()` | ì „í™”ë²ˆí˜¸ í‘œì¤€í™” |
| `isIslandRemoteArea()` | ë„ì„œ/ì‚°ê°„ ì§€ì—­ í™•ì¸ |

---

## API ì—”ë“œí¬ì¸íŠ¸

### POST /api/address/validate

ì£¼ì†Œ ë°°ì—´ì„ ê²€ì¦í•©ë‹ˆë‹¤.

**ìš”ì²­:**
```json
{
  "addresses": [
    { "rowIndex": 0, "address": "ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123 101ë™ 1001í˜¸", "phone": "01012345678" },
    { "rowIndex": 1, "address": "ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ íŒêµë¡œ 456", "phone": "010-1234-5678" }
  ]
}
```

**ì‘ë‹µ:**
```json
{
  "success": true,
  "results": [
    {
      "rowIndex": 0,
      "originalAddress": "ì„œìš¸ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123 101ë™ 1001í˜¸",
      "status": "valid",
      "standardAddress": "ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123",
      "detailAddress": "101ë™ 1001í˜¸",
      "normalizedDetailAddress": "101ë™ 1001í˜¸",
      "fullAddress": "ì„œìš¸íŠ¹ë³„ì‹œ ê°•ë‚¨êµ¬ í…Œí—¤ë€ë¡œ 123 101ë™ 1001í˜¸",
      "zipCode": "06142",
      "buildingName": "OOë¹Œë”©",
      "reasonCode": "OK_STD",
      "isIslandRemote": false,
      "isLengthExceeded": false,
      "formattedPhone": "010-1234-5678",
      "phoneModified": true
    }
  ],
  "validCount": 1,
  "warningCount": 0,
  "invalidCount": 1,
  "islandRemoteCount": 0,
  "lengthExceededCount": 0
}
```

### GET /api/address/health

API ìƒíƒœ í™•ì¸

### GET /api/address/search?query=ê²€ìƒ‰ì–´

ì£¼ì†Œ ê²€ìƒ‰

---

## í†µí•© ë°©ë²•

### 1. íŒŒì¼ ë³µì‚¬

```
server/
â”œâ”€â”€ address-validation.ts
â”œâ”€â”€ address-learning.ts
â”œâ”€â”€ ai-address-enhancer.ts
â””â”€â”€ ai-pattern-analyzer.ts
```

### 2. ìŠ¤í‚¤ë§ˆ ì¶”ê°€

`shared/schema.ts`ì— `addressLearningData` í…Œì´ë¸” ì¶”ê°€

### 3. ë¼ìš°í„° ë“±ë¡

```typescript
// server/routes.ts ë˜ëŠ” server/index.ts
import addressValidationRouter from './address-validation';

app.use('/api/address', addressValidationRouter);
```

### 4. í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

```bash
JUSO_API_KEY=your_juso_api_key
ANTHROPIC_API_KEY=your_anthropic_api_key
ENABLE_AI_ADDRESS_NORMALIZATION=true
```

### 5. ë§ˆì´ê·¸ë ˆì´ì…˜

```bash
npm run db:push
```

---

## ì‚¬ìš© ì˜ˆì‹œ

### í”„ë¡ íŠ¸ì—”ë“œì—ì„œ í˜¸ì¶œ

```typescript
const validateAddresses = async (addresses: Array<{ address: string; phone?: string }>) => {
  const response = await fetch('/api/address/validate', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      addresses: addresses.map((addr, idx) => ({
        rowIndex: idx,
        address: addr.address,
        phone: addr.phone
      }))
    })
  });
  
  return response.json();
};
```

---

## ë¼ì´ì„ ìŠ¤

ì´ ì½”ë“œëŠ” TopselPro í”„ë¡œì íŠ¸ì˜ ì¼ë¶€ì…ë‹ˆë‹¤.
