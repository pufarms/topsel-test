# 탑셀러 외주 협력업체 시스템 - Phase 1 구현 프롬프트

## Replit AI 사용 가이드

> **사용법**: 아래 프롬프트를 Phase 1-1부터 순서대로 Replit AI에 붙여넣기 하세요.
> 각 단계가 완료되면 다음 단계로 넘어갑니다.
> **반드시 순서대로 진행**해야 합니다 (1-1 → 1-2 → 1-3 → 1-4 → 1-5 → 1-6).

---

## Phase 1-1: vendors 테이블 생성 + 관리자 업체 등록/관리 화면

```
[작업 지시]
탑셀러 관리자 시스템에 외주 협력업체를 관리하는 기능을 추가합니다.

⚠️ 중요 원칙:
- 기존 코드, DB 구조, 기능에 영향을 주지 않도록 "추가"만 합니다.
- 기존 테이블을 수정하지 마세요 (이 단계에서는 신규 테이블만 생성).
- 기존 라우팅, 미들웨어, 인증 로직을 건드리지 마세요.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: DB - vendors 테이블 생성]

신규 테이블 "vendors"를 생성합니다. 기존 테이블은 절대 수정하지 마세요.

vendors 테이블 스키마:
- id: serial PRIMARY KEY
- companyName: varchar(100) NOT NULL — 업체명
- contactName: varchar(50) — 담당자명
- contactPhone: varchar(20) — 연락처
- contactEmail: varchar(100) — 이메일
- loginId: varchar(50) UNIQUE — 대시보드 로그인 ID (/partner 접속용)
- loginPassword: varchar(255) — 비밀번호 (bcrypt 해시 저장)
- settlementCycle: varchar(20) DEFAULT 'monthly' — 정산주기 (monthly / weekly / per_order), 업체마다 다름
- bankName: varchar(50) — 정산 은행명
- bankAccount: varchar(50) — 정산 계좌번호
- bankHolder: varchar(50) — 예금주
- isActive: boolean DEFAULT true — 활성 여부
- memo: text — 메모
- createdAt: timestamp DEFAULT NOW()
- updatedAt: timestamp DEFAULT NOW()

마이그레이션 파일로 생성하되, 기존 마이그레이션 파일은 건드리지 마세요.

[2단계: API - 외주업체 CRUD]

관리자 전용 API 라우트를 추가합니다.
기존 라우트 파일에 추가하지 말고, 별도 파일(예: routes/admin/vendors.js 또는 해당 프로젝트 구조에 맞게)로 생성하세요.

API 엔드포인트:
- GET /api/admin/vendors — 업체 목록 조회 (isActive 필터, 검색)
- GET /api/admin/vendors/:id — 업체 상세 조회
- POST /api/admin/vendors — 업체 등록 (loginPassword는 bcrypt 해시)
- PUT /api/admin/vendors/:id — 업체 수정 (비밀번호 변경 시에만 해시 재생성)
- PUT /api/admin/vendors/:id/toggle-active — 활성/비활성 토글

인증: 기존 관리자 인증 미들웨어를 그대로 사용하세요.
비밀번호: bcrypt로 해시하여 저장, 응답에는 비밀번호 필드 제외.

[3단계: 관리자 화면 - 외주업체 관리 페이지]

관리자 대시보드에 "외주업체 관리" 메뉴를 추가합니다.
기존 메뉴/사이드바 구조에 메뉴 항목만 추가하고, 기존 페이지는 수정하지 마세요.

화면 구성:
1. 업체 목록 페이지
   - 테이블: 업체명, 담당자, 연락처, 정산주기, 활성상태, 등록일
   - 필터: 전체 / 활성 / 비활성
   - 검색: 업체명, 담당자명
   - 액션: 등록 버튼, 각 행에 수정/활성토글 버튼

2. 업체 등록/수정 모달 또는 페이지
   - 입력 필드: 업체명*, 담당자명, 연락처, 이메일
   - 로그인 정보: 로그인ID*, 비밀번호* (등록 시 필수, 수정 시 선택)
   - 정산 정보: 정산주기(월1회/주1회/건별 드롭다운), 은행명, 계좌번호, 예금주
   - 기타: 메모

[완료 확인]
- vendors 테이블이 정상 생성되는지 확인
- 업체 등록 → 목록 조회 → 수정 → 활성/비활성 토글이 모두 작동하는지 확인
- 기존 기능(상품등록, 주문관리, 회원관리 등)이 정상 작동하는지 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1-2: product_vendors 테이블 + 상품등록 화면에 외주업체 섹션 추가

```
[작업 지시]
상품과 외주업체를 연결하는 매핑 테이블을 만들고, 상품등록 화면에 외주업체 섹션을 추가합니다.

⚠️ 중요 원칙:
- 기존 상품등록 로직(원가계산, 공급가계산, 마진율 등)은 절대 수정하지 마세요.
- 기존 가격 파이프라인(등록→차주예상→현재공급가)에 영향을 주지 마세요.
- 외주업체 섹션은 기존 화면 "하단에 추가"하는 방식으로 구현합니다.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: DB - product_vendors 테이블 생성]

신규 테이블 "product_vendors"를 생성합니다.

product_vendors 테이블 스키마:
- id: serial PRIMARY KEY
- productCode: varchar — 상품코드 (product_registrations의 상품코드 참조)
- vendorId: integer REFERENCES vendors(id) — 외주업체 ID
- vendorPrice: integer NOT NULL — 이 업체의 매입가 (정산 기준, 수정 가능)
- isActive: boolean DEFAULT true — 활성 여부
- memo: text — 메모
- updatedAt: timestamp DEFAULT NOW() — 매입가 최종 수정일
- UNIQUE(productCode, vendorId) — 동일 상품+업체 중복 방지

기존 테이블은 수정하지 마세요.

[2단계: API - 상품-업체 매핑 CRUD]

API 엔드포인트 (기존 API 파일과 별도로 생성):
- GET /api/admin/product-vendors/:productCode — 해당 상품의 공급업체 목록
- POST /api/admin/product-vendors — 상품-업체 매핑 추가 (productCode, vendorId, vendorPrice)
- PUT /api/admin/product-vendors/:id — 매입가/메모 수정
- DELETE /api/admin/product-vendors/:id — 매핑 삭제 (또는 isActive=false)

[3단계: 상품등록 화면 - 외주업체 섹션 추가]

기존 상품등록 화면의 **하단**에 "외주 공급업체" 섹션을 추가합니다.

⚠️ 주의: 기존 상품등록 폼의 필드, 계산 로직, 저장 로직은 일절 수정하지 마세요.
외주업체 섹션은 별도 컴포넌트로 만들어서 하단에 배치만 합니다.

화면 구성:
- "외주업체 공급 가능" 체크박스 (토글)
- 체크 시 아래 영역 표시:
  - 업체 선택 드롭다운 (활성 업체만, vendors 테이블에서 조회)
  - 매입가 입력 필드 (원 단위)
  - 메모 입력
  - "추가" 버튼
- 추가된 업체 목록 테이블:
  - 컬럼: 업체명, 매입가, 메모, 수정일, 액션(수정/삭제)
  - 매입가 인라인 수정 가능

이 섹션의 데이터는 product_vendors 테이블에 저장됩니다.
기존 상품 저장 버튼과는 독립적으로 동작합니다 (업체 추가/수정/삭제는 즉시 API 호출).

[완료 확인]
- 상품등록 화면 하단에 외주업체 섹션이 표시되는지 확인
- 업체 추가 → 매입가 수정 → 삭제가 정상 동작하는지 확인
- ⚡ 기존 상품등록 기능(원가계산, 공급가, 저장)이 이전과 동일하게 작동하는지 반드시 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1-3: pending_orders 테이블에 외주 관련 필드 추가

```
[작업 지시]
기존 pending_orders 테이블에 외주 배분을 위한 필드 3개를 추가합니다.

⚠️ 중요 원칙:
- pending_orders 테이블에 컬럼을 "추가"만 합니다. 기존 컬럼은 수정/삭제하지 마세요.
- 추가하는 필드는 모두 nullable이므로, 기존 데이터와 기존 코드에 영향 없습니다.
- 기존 주문 관련 로직(주문 생성, 상태 변경, 정산 등)은 수정하지 마세요.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: DB 마이그레이션 - 필드 추가]

pending_orders 테이블에 다음 3개 컬럼을 추가합니다:

ALTER TABLE pending_orders ADD COLUMN IF NOT EXISTS vendorId integer DEFAULT NULL;
ALTER TABLE pending_orders ADD COLUMN IF NOT EXISTS fulfillmentType varchar(10) DEFAULT 'self';
ALTER TABLE pending_orders ADD COLUMN IF NOT EXISTS vendorPrice integer DEFAULT NULL;

설명:
- vendorId: 배정된 외주업체 ID (NULL이면 자체 발송 또는 미배정)
- fulfillmentType: 'self'(자체, 기본값) 또는 'vendor'(외주)
- vendorPrice: 해당 주문에 적용된 매입가 (외주 정산 기준)

⚠️ 기본값이 있으므로 기존 데이터에 영향 없음을 확인하세요.
⚠️ 기존 pending_orders를 조회/수정하는 코드에는 손대지 마세요. 새 필드는 나중 단계에서 사용합니다.

[2단계: 주문 목록 화면 - 컬럼 추가]

관리자 주문 목록 화면에 다음 컬럼을 추가합니다:
- "발송구분" 컬럼: fulfillmentType 값 표시 (self → "자체", vendor → "외주")
- "공급업체" 컬럼: vendorId가 있으면 해당 업체명 표시, 없으면 "-"

⚠️ 기존 주문 목록의 다른 컬럼, 정렬, 필터, 페이징은 수정하지 마세요.
기존 컬럼 옆에 새 컬럼을 "추가"만 합니다.

주문 목록 API에서 vendorId가 있을 때 vendors 테이블과 JOIN하여 업체명을 가져오도록 쿼리를 수정합니다.
LEFT JOIN을 사용하여 vendorId가 NULL인 기존 주문도 정상 조회되도록 합니다.

[완료 확인]
- pending_orders에 새 컬럼 3개가 추가되었는지 확인
- 기존 주문 데이터가 정상 조회되는지 확인 (새 컬럼은 기본값)
- 주문 목록에 발송구분/공급업체 컬럼이 표시되는지 확인
- ⚡ 기존 주문 생성, 상태 변경, 정산 프로세스가 정상 동작하는지 반드시 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1-4: product_registrations 테이블에 외주상품 플래그 추가 + 전송 검증 로직 수정

```
[작업 지시]
상품에 외주상품 여부를 표시하는 플래그를 추가하고, 전송 검증 로직을 수정합니다.

⚠️ 중요 원칙:
- 기존 가격 계산 로직(원물원가 + 6비용 + 마진율)은 절대 수정하지 마세요.
- 기존 3단계 파이프라인(등록→차주예상→현재공급가)은 수정하지 마세요.
- 전송 검증 로직만 "조건 분기"를 추가합니다.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: DB 마이그레이션 - 플래그 추가]

product_registrations 테이블에 컬럼을 추가합니다:

ALTER TABLE product_registrations ADD COLUMN IF NOT EXISTS isVendorProduct boolean DEFAULT false;

설명:
- isVendorProduct: true이면 외주상품 (외주업체가 발송 가능)
- 기본값 false이므로 기존 상품은 모두 자체상품으로 유지됨

[2단계: 전송 검증 로직 수정]

차주예상공급가 전송 시 검증 로직을 찾아서, 아래 조건 분기를 추가합니다.

현재 검증 로직: 재료매핑(mappingStatus=complete) 확인 후 전송 허용

변경 후 검증 로직:
- isVendorProduct = false (자체상품만): 기존과 동일, 재료매핑 완료 필수
- isVendorProduct = true AND product_vendors에 매핑이 1건 이상 있고 AND 재료매핑 미완료: 재료매핑 불필요, 전송 허용
- isVendorProduct = true AND 재료매핑 완료: 전송 허용 (자체+외주 겸용)

⚠️ 기존 자체상품의 검증 로직은 변경하지 마세요. 위 조건은 isVendorProduct=true일 때만 적용됩니다.
⚠️ 가격 계산, 공급가 산출, 마진율 적용 등의 로직은 건드리지 마세요.

[3단계: 상품등록 화면 - 외주상품 플래그 연동]

Phase 1-2에서 추가한 "외주업체 공급 가능" 체크박스를 isVendorProduct 필드와 연동합니다.
- 체크 ON → isVendorProduct = true 저장
- 체크 OFF → isVendorProduct = false 저장
- 기존 상품 수정 시, isVendorProduct 값에 따라 체크박스 상태 반영

[완료 확인]
- 자체상품: 재료매핑 없이 전송 시도 → 차단됨 (기존과 동일) ✓
- 외주상품(isVendorProduct=true) + 업체매핑 있음 + 재료매핑 없음 → 전송 허용됨 ✓
- 외주상품 + 업체매핑 없음 → 전송 차단됨 ✓
- ⚡ 기존 자체상품의 전송 프로세스가 이전과 동일하게 작동하는지 반드시 확인
- ⚡ 가격 계산, 공급가 산출이 이전과 동일한지 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1-5: 상품 목록에 자체/외주 필터 추가

```
[작업 지시]
현재공급가 상품 목록 화면에 자체/외주 필터를 추가합니다.

⚠️ 중요 원칙:
- 기존 상품 목록의 컬럼, 정렬, 검색, 페이징은 수정하지 마세요.
- 필터 옵션을 "추가"만 합니다.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: API - 필터 파라미터 추가]

상품 목록 조회 API에 필터 파라미터를 추가합니다:
- productType 파라미터: 'all'(기본값, 전체) / 'self'(자체상품만) / 'vendor'(외주상품만)

쿼리 조건:
- all: 기존과 동일 (WHERE 조건 추가 없음)
- self: WHERE isVendorProduct = false (또는 isVendorProduct IS NULL)
- vendor: WHERE isVendorProduct = true

⚠️ 기존 쿼리의 다른 WHERE 조건, JOIN, 정렬은 수정하지 마세요.
productType 조건을 AND로 추가만 합니다.
파라미터가 없거나 'all'이면 기존과 완전히 동일하게 동작해야 합니다.

[2단계: 화면 - 필터 UI 추가]

상품 목록 화면의 기존 필터 영역에 "상품구분" 필터를 추가합니다:
- 버튼 또는 드롭다운: 전체 / 자체상품 / 외주상품
- 기본값: 전체 (기존과 동일한 결과)

⚠️ 기존 필터(검색, 카테고리 등)는 수정하지 마세요.

[완료 확인]
- "전체" 선택 시 기존과 동일한 상품 목록이 표시되는지 확인
- "자체상품" 선택 시 isVendorProduct=false인 상품만 표시되는지 확인
- "외주상품" 선택 시 isVendorProduct=true인 상품만 표시되는지 확인
- ⚡ 기존 필터, 검색, 페이징이 정상 동작하는지 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1-6: 자체 발송 시 자동 재고 차감 로직 구현

```
[작업 지시]
자체 발송(fulfillmentType='self') 주문이 "배송중"으로 전환될 때, product_stocks에서 자동으로 재고를 차감하는 로직을 추가합니다.

⚠️ 중요 원칙:
- 기존 주문 상태 변경 로직의 흐름은 유지합니다. 재고 차감 로직을 "추가"만 합니다.
- 외주 발송(fulfillmentType='vendor')인 주문은 재고 차감하지 않습니다.
- 기존 정산 로직(settlement_history 등)은 수정하지 마세요.
- 트랜잭션 처리하여 상태 변경과 재고 차감이 원자적으로 동작하도록 합니다.
- 작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[1단계: 재고 차감 로직 추가]

주문 상태가 "배송중"으로 전환되는 기존 코드를 찾아서, 해당 로직 내에 재고 차감을 추가합니다.

조건:
- fulfillmentType = 'self' (자체 발송)인 경우에만 실행
- fulfillmentType = 'vendor' (외주)이거나, fulfillmentType이 NULL인 경우 → 재고 차감 안 함

차감 로직:
1. 해당 주문의 상품코드(productCode)와 수량(quantity)을 확인
2. product_stocks 테이블에서 해당 상품의 재고를 차감
3. 재고가 부족한 경우 → 경고 로그 남기되, 상태 전환은 허용 (관리자가 수동 관리)

⚠️ 기존 "배송중" 전환 로직을 감싸는 형태로 구현하세요.
기존 코드의 동작 순서를 변경하지 마세요.

예시 수도코드:
```
// 기존 배송중 전환 로직 시작
BEGIN TRANSACTION;

// ... 기존 상태 변경 코드 (수정하지 않음) ...

// [추가] 자체 발송인 경우 재고 차감
IF (order.fulfillmentType === 'self' OR order.fulfillmentType IS NULL) {
  // product_stocks에서 재고 차감
  UPDATE product_stocks SET currentStock = currentStock - order.quantity
  WHERE productCode = order.productCode;
  
  // 재고 부족 시 로그만 남김
  IF (newStock < 0) {
    console.warn(`재고 부족 경고: ${productCode}, 현재 재고: ${newStock}`);
  }
}

// ... 기존 정산 등 후속 처리 (수정하지 않음) ...

COMMIT;
```

[2단계: 외주 발송은 재고 차감 제외 확인]

fulfillmentType = 'vendor'인 주문이 배송중으로 전환될 때:
- product_stocks의 재고가 변하지 않는 것을 확인
- 외주상품은 외주업체가 재고를 관리하므로 탑셀러 재고에서 차감하면 안 됨

[완료 확인]
- 자체 발송 주문 → 배송중 전환 시 재고가 차감되는지 확인
- 외주 발송 주문 → 배송중 전환 시 재고가 변하지 않는지 확인
- 기존 주문(fulfillmentType 미설정) → 기존과 동일하게 동작하는지 확인
- ⚡ 기존 배송중 전환 프로세스(정산 포함)가 정상 동작하는지 반드시 확인
- ⚡ 기존 주문 상태 변경 흐름(상품준비중→배송준비중→배송중)이 깨지지 않았는지 확인
- 결과를 한글로 보고해 주세요
```

---

## Phase 1 완료 후 통합 테스트 프롬프트

```
[작업 지시]
Phase 1 전체 작업의 통합 테스트를 진행합니다.
작업 진행 상황 설명과 작업 결과는 항상 한글로 보여주세요.

[테스트 시나리오]

1. 기존 기능 정상 동작 확인 (회귀 테스트)
   - 자체상품 등록 → 원가계산 → 공급가 산출이 기존과 동일한지
   - 자체상품 재료매핑 → 차주예상공급가 전송이 정상인지
   - 회원 주문 등록(엑셀 업로드) → 주문 생성이 정상인지
   - 주문 상태 변경(상품준비중→배송준비중→배송중) 정상인지
   - 회원 정산(배송중 전환 시 자동 정산)이 정상인지

2. 신규 기능 테스트
   a) 외주업체 관리
      - 업체 등록 (A농원, B과수원) → 목록 조회 → 수정 → 활성/비활성 토글
   
   b) 상품-업체 매핑
      - 기존 상품에 외주업체 연결 → 매입가 설정
      - 외주상품 플래그(isVendorProduct) 활성화
   
   c) 전송 검증
      - 외주상품 + 업체매핑 있음 + 재료매핑 없음 → 전송 성공
      - 외주상품 + 업체매핑 없음 → 전송 실패
      - 자체상품 + 재료매핑 없음 → 전송 실패 (기존과 동일)
   
   d) 상품 필터
      - 전체/자체/외주 필터가 정상 동작하는지
   
   e) 주문 목록
      - 발송구분, 공급업체 컬럼이 표시되는지
   
   f) 재고 차감
      - 자체 발송 → 배송중 전환 시 재고 차감됨
      - 외주 발송 → 배송중 전환 시 재고 미차감

[결과 보고]
각 테스트 항목별로 ✅ 통과 / ❌ 실패를 한글로 보고해 주세요.
실패 항목이 있으면 원인과 수정 방안을 함께 알려주세요.
```

---

## 트러블슈팅 가이드

### 문제가 발생하면 아래 프롬프트를 사용하세요:

```
[긴급 수정 요청]
방금 작업한 내용에서 문제가 발생했습니다.

문제 현상: [여기에 에러 메시지 또는 문제 설명 입력]

⚠️ 수정 원칙:
- 이번 단계에서 변경한 코드만 수정하세요.
- 기존 코드(이번 단계 이전에 존재하던 코드)는 수정하지 마세요.
- 수정 전후 차이를 한글로 설명해 주세요.
- 수정 후 기존 기능이 정상 동작하는지 확인해 주세요.
```

### 기존 기능이 깨졌을 때:

```
[기존 기능 복구 요청]
이번 작업 후 기존 기능에 문제가 발생했습니다.

깨진 기능: [여기에 문제가 된 기존 기능 설명]

⚠️ 복구 원칙:
- 이번 단계에서 추가/수정한 코드에서 원인을 찾아주세요.
- 기존 코드를 원래대로 되돌리고, 새 기능은 다른 방법으로 구현해 주세요.
- 기존 기능 복구가 최우선입니다. 새 기능은 기존 기능에 영향이 없는 방식으로만 추가하세요.
- 결과를 한글로 보고해 주세요.
```
